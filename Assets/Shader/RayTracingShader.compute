#pragma kernel CSMain
#include "UnityCG.cginc"

RWTexture2D<float4> Result; // writable texture to store the final rendered image.

float4x4 CameraToWorld;
float4x4 CameraInverseProjection;
float4 DirectionalLight;
float2 PixelOffset;

Texture2D<float4> SkyboxTexture;
SamplerState sampler_SkyboxTexture;
static const float PI = 3.14159265f;

struct Sphere
{
    float3 position;
    float radius;
    float3 albedo;
    float3 specular;
};

StructuredBuffer<Sphere> SpheresBuffer;

struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
};

struct RayHit
{
    float3 position;
    float distance;
    float3 normal;
    float3 albedo;
    float3 specular;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Camera origin in world space
    float3 origin = mul(CameraToWorld, float4(0, 0, 0, 1)).xyz;

    // Unproject from NDC → view space
    float4 pos = mul(CameraInverseProjection, float4(uv, 1.0f, 1.0f));
    pos /= pos.w; // perspective divide
    float3 viewDir = normalize(pos.xyz); // direction in view space

    // Convert to world space
    float3 direction = mul(CameraToWorld, float4(viewDir, 0)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}


RayHit CreateRayHit()
{
    RayHit hit;

    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    hit.albedo = float3(0.0f, 0.0f, 0.0f);
    hit.specular = float3(0.0f, 0.0f, 0.0f);

    return hit;
}


void IntersectGroundPlane(Ray ray, inout RayHit bestHit)
{
    float denom = ray.direction.y;

    // 1. Only intersect if ray is pointing downward
    // 2. Avoid division by zero and near-zero

    if (denom >= - 0.0001) // if ray is not pointing down enough
    return;

    float t = - ray.origin.y / denom; // ground plane is aligned with XZ plane passing through the origin

    if (t > 0 && t < bestHit.distance)
    {
        bestHit.distance = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = float3(0.0f, 1.0f, 0.0f); // plane normal is along the Y direction

        // The ground plane is a diffuse surface
        bestHit.albedo = float3(0.843f, 0.722f, 0.651f);
        bestHit.specular = float3(0.04f, 0.04f, 0.04f);
    }
}


void IntersectSphere(Ray ray, inout RayHit bestHit, uint sphereIndex)
{
    Sphere sphere = SpheresBuffer[sphereIndex];

    float3 d = ray.origin - sphere.position; // vector from sphere center to ray origin

    // Quadratic coefficients for: t² + bt + c = 0
    float a = 1.0f;
    float b = 2.0f * dot(ray.direction, d);
    float c = dot(d, d) - sphere.radius * sphere.radius;

    float discriminant = b * b - 4.0f * a * c;
    if (discriminant < 0.0f)
    return; // no intersection

    float sqrtDisc = sqrt(discriminant);

    // Find two roots
    float t1 = (- b - sqrtDisc) * 0.5f; // divided by 2a = 2
    float t2 = (- b + sqrtDisc) * 0.5f;

    // Pick nearest positive root
    float t = (t1 > 0.0f) ? t1 : t2;
    if (t <= 0.0f || t >= bestHit.distance)
    return;

    // Update closest hit
    bestHit.distance = t;
    bestHit.position = ray.origin + t * ray.direction;
    bestHit.normal = normalize(bestHit.position - sphere.position);
    bestHit.albedo = sphere.albedo;
    bestHit.specular = sphere.specular;
}

RayHit Trace(Ray ray)
{
    RayHit bestHit = CreateRayHit();

    // Trace ground plane
    IntersectGroundPlane(ray, bestHit);

    // Trace spheres
    uint numSpheres, stride;
    SpheresBuffer.GetDimensions(numSpheres, stride);

    for (uint i = 0; i < numSpheres; i ++)
    IntersectSphere(ray, bestHit, i);

    return bestHit;
}


bool TraceShadowRay(Ray ray)
{
    // Check ground plane
    float denom = ray.direction.y;
    if (denom < - 0.0001)
    {
        float t = - ray.origin.y / denom;
        if (t > 0.0f)
        return true; // hit ground
    }

    // Check all spheres
    uint numSpheres, stride;
    SpheresBuffer.GetDimensions(numSpheres, stride);

    for (uint i = 0; i < numSpheres; i ++)
    {
        Sphere sphere = SpheresBuffer[i];
        float3 d = ray.origin - sphere.position;
        float b = 2.0f * dot(ray.direction, d);
        float c = dot(d, d) - sphere.radius * sphere.radius;
        float discriminant = b * b - 4.0f * c;

        if (discriminant >= 0.0f)
        {
            float sqrtDisc = sqrt(discriminant);
            float t1 = (- b - sqrtDisc) * 0.5f;
            float t2 = (- b + sqrtDisc) * 0.5f;

            if (t1 > 0.0f || t2 > 0.0f)
            return true; // any intersection blocks the light
        }
    }

    return false; // clear line of sight
}



float3 Shade(inout Ray ray, RayHit hit)
{
    // Case I: SkyBox
    if (hit.distance == 1.#INF)
    {
        ray.energy = 0.0f;

        float3 dir = normalize(ray.direction);

        // longitude
        float phi = atan2(dir.z, dir.x);
        phi = (phi + PI) / (2.0f * PI);

        // latitude
        float theta = acos(dir.y) / PI;
        theta = 1 - theta;

        float2 skyUV = float2(phi, theta);
        float3 sky = SkyboxTexture.SampleLevel(sampler_SkyboxTexture, skyUV, 0).xyz;

        float skyboxIntensityFactor = 1.36f;
        return sky * skyboxIntensityFactor;
    }

    bool isMetal = (hit.albedo.x == 0 && hit.albedo.y == 0 && hit.albedo.z == 0);

    // Case II: DIFFUSE Spheres — rough, matte
    if (! isMetal)
    {
        float3 L = normalize(- DirectionalLight.xyz);

        // Shadow test first
        Ray shadowRay = CreateRay(hit.position + hit.normal * 0.005f, L);
        bool inShadow = TraceShadowRay(shadowRay);
        if (inShadow)
        return float3(0, 0, 0); // fully shadowed — light blocked by another object

        // Lighting only if visible (Lambert + Blinn–Phong)
        float NdotL = saturate(dot(hit.normal, L));
        float3 diffuse = hit.albedo * DirectionalLight.w * NdotL;
        float3 V = - ray.direction;
        float3 H = normalize(L + V);
        float3 specular = hit.specular * pow(saturate(dot(hit.normal, H)), 32.0f);

        ray.energy = 0; // stop further ray bounces for diffuse surfaces

        return diffuse + specular;
    }

    // Case III: GLOSSY METALLIC — perfect specular reflection
    else
    {
        ray.origin = hit.position + hit.normal * 0.005f;
        ray.direction = reflect(ray.direction, hit.normal);
        ray.energy *= hit.specular; // throughput update for reflective material

        return float3(0, 0, 0);
    }
}


[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    // Convert pixel coordinates to normalized device coordinates [-1, 1]
    float2 uv = (id.xy + PixelOffset) / float2(width, height) * 2.0f - 1.0f;

    // Generate a primary ray from the camera through this pixel
    Ray ray = CreateCameraRay(uv);

    float3 shadedColor = float3(0, 0, 0);

    // Trace multiple bounces (for reflections)
    for (int bounce = 0; bounce < 10; bounce ++)
    {
        float3 incidentRayEnergy = ray.energy; // current light intensity carried by the ray

        RayHit hit = Trace(ray); // find intersection with the scene

        float3 reflectedRadiance = Shade(ray, hit); // light reflected / emitted from the surface toward the camera
        shadedColor += incidentRayEnergy * reflectedRadiance; // accumulate final pixel color

        if (! any(ray.energy)) // stop when the ray no longer carries light
        break;
    }

    // Store final pixel color
    Result[id.xy] = float4(shadedColor, 1);
}
